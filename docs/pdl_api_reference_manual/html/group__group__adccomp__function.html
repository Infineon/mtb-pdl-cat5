<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MTB CAT5 Peripheral driver library: Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.infineon.com/"><img alt="Logo" src="IFX_LOGO_RGB.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MTB CAT5 Peripheral driver library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li><a href="page_getting_started.html"><span>Getting&#160;started</span></a></li>
      <li><a href="modules.html"><span>PDL&#160;API&#160;Reference</span></a></li>
      <li><a href="usergroup0.html"><span>Online&#160;Documentation</span></a></li>
      <li><a href="usergroup1.html"><span>Device&#160;Catalog</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)"
               onblur="searchBox.OnSearchFieldFocus(false)"
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__adccomp__function.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0"
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Functions<div class="ingroups"><a class="el" href="group__group__adccomp.html">ADCcomp      (ADCCOMP, LPCOMP / NTD - Noise Threshold Detector)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga21da9dedd2be45f08e7d8599f345689a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__adccomp__function.html#ga21da9dedd2be45f08e7d8599f345689a">Cy_ADCCOMP_LPCOMP_Init</a> (CyADCCOMP_Type *base, <a class="el" href="group__group__adccomp__data__structures.html#ga4f527f373ce27e67a7a13aab90b9df26">cy_en_adccomp_lpcomp_id_t</a> lpcompId, <a class="el" href="group__group__adccomp__data__structures.html#ga66b412bde45d12e19b117f987a402dd7">cy_en_adccomp_lpcomp_mode_t</a> lpcompMode, <a class="el" href="structcy__stc__adccomp__lpcomp__config__t.html">cy_stc_adccomp_lpcomp_config_t</a> *pCfg)</td></tr>
<tr class="memdesc:ga21da9dedd2be45f08e7d8599f345689a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures Low power comparator for DC mode or noise threshold detect(NTD) mode.  <a href="#ga21da9dedd2be45f08e7d8599f345689a">More...</a><br /></td></tr>
<tr class="separator:ga21da9dedd2be45f08e7d8599f345689a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad88fc0bab64965cbea93facd34aa8576"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__adccomp__function.html#gad88fc0bab64965cbea93facd34aa8576">Cy_ADCCOMP_LPCOMP_Enable</a> (CyADCCOMP_Type *base, <a class="el" href="group__group__adccomp__data__structures.html#ga4f527f373ce27e67a7a13aab90b9df26">cy_en_adccomp_lpcomp_id_t</a> lpcompId)</td></tr>
<tr class="memdesc:gad88fc0bab64965cbea93facd34aa8576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable comparator for either DC threshold detection or NTD(Noise Threshold mode).  <a href="#gad88fc0bab64965cbea93facd34aa8576">More...</a><br /></td></tr>
<tr class="separator:gad88fc0bab64965cbea93facd34aa8576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b430d444c4f7492cc73084bfd3b828f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__adccomp__function.html#ga7b430d444c4f7492cc73084bfd3b828f">Cy_ADCCOMP_LPCOMP_Disable</a> (CyADCCOMP_Type *base, <a class="el" href="group__group__adccomp__data__structures.html#ga4f527f373ce27e67a7a13aab90b9df26">cy_en_adccomp_lpcomp_id_t</a> lpcompId)</td></tr>
<tr class="memdesc:ga7b430d444c4f7492cc73084bfd3b828f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables comparator.  <a href="#ga7b430d444c4f7492cc73084bfd3b828f">More...</a><br /></td></tr>
<tr class="separator:ga7b430d444c4f7492cc73084bfd3b828f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e743e28b37cf95fb7af12f792f36878"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__adccomp__function.html#ga0e743e28b37cf95fb7af12f792f36878">Cy_ADCCOMP_LPCOMP_DeInit</a> (CyADCCOMP_Type *base, <a class="el" href="group__group__adccomp__data__structures.html#ga4f527f373ce27e67a7a13aab90b9df26">cy_en_adccomp_lpcomp_id_t</a> lpcompId)</td></tr>
<tr class="memdesc:ga0e743e28b37cf95fb7af12f792f36878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable comparator and resets configuration to default values, i.e.  <a href="#ga0e743e28b37cf95fb7af12f792f36878">More...</a><br /></td></tr>
<tr class="separator:ga0e743e28b37cf95fb7af12f792f36878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabca5ed32c461f0ac0af14b315ecdd076"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__adccomp__function.html#gabca5ed32c461f0ac0af14b315ecdd076">Cy_ADCCOMP_LPCOMP_EnableWakeConfig</a> (<a class="el" href="group__group__adccomp__data__structures.html#ga4f527f373ce27e67a7a13aab90b9df26">cy_en_adccomp_lpcomp_id_t</a> lpcompId)</td></tr>
<tr class="memdesc:gabca5ed32c461f0ac0af14b315ecdd076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures comparator as wake source.  <a href="#gabca5ed32c461f0ac0af14b315ecdd076">More...</a><br /></td></tr>
<tr class="separator:gabca5ed32c461f0ac0af14b315ecdd076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa63cee1c4bced8486ce2ecccf5fc9099"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__adccomp__function.html#gaa63cee1c4bced8486ce2ecccf5fc9099">Cy_ADCCOMP_LPCOMP_DisableWakeConfig</a> (<a class="el" href="group__group__adccomp__data__structures.html#ga4f527f373ce27e67a7a13aab90b9df26">cy_en_adccomp_lpcomp_id_t</a> lpcompId)</td></tr>
<tr class="memdesc:gaa63cee1c4bced8486ce2ecccf5fc9099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables comparator wake source configuration.  <a href="#gaa63cee1c4bced8486ce2ecccf5fc9099">More...</a><br /></td></tr>
<tr class="separator:gaa63cee1c4bced8486ce2ecccf5fc9099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a1d784ae85536473f28303581038aa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__adccomp__function.html#ga4a1d784ae85536473f28303581038aa8">Cy_ADCCOMP_LPCOMP_ClearLatch</a> (CyADCCOMP_Type *base, <a class="el" href="group__group__adccomp__data__structures.html#ga4f527f373ce27e67a7a13aab90b9df26">cy_en_adccomp_lpcomp_id_t</a> lpcompId)</td></tr>
<tr class="memdesc:ga4a1d784ae85536473f28303581038aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the comparator latched status.  <a href="#ga4a1d784ae85536473f28303581038aa8">More...</a><br /></td></tr>
<tr class="separator:ga4a1d784ae85536473f28303581038aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga708ca74f75b3729b5327b646799db887"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__adccomp__function.html#ga708ca74f75b3729b5327b646799db887">Cy_ADCCOMP_ADC_Init</a> (CyADCCOMP_Type *base, <a class="el" href="group__group__adccomp__data__structures.html#gaf20680e29db015c9b65df5ff276cfd0a">cy_en_adccomp_adc_mode_t</a> adcMode, <a class="el" href="structcy__stc__adccomp__adc__config__t.html">cy_stc_adccomp_adc_config_t</a> *pCfg)</td></tr>
<tr class="memdesc:ga708ca74f75b3729b5327b646799db887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures ADC block for DC conversion or analog MIC mode for audio acquistion.  <a href="#ga708ca74f75b3729b5327b646799db887">More...</a><br /></td></tr>
<tr class="separator:ga708ca74f75b3729b5327b646799db887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58d47f10546f2e39e96a129086d04123"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__adccomp__function.html#ga58d47f10546f2e39e96a129086d04123">Cy_ADCCOMP_ADC_SelectDcChannel</a> (CyADCCOMP_Type *base, <a class="el" href="group__group__adccomp__data__structures.html#ga5d18e36866381d90b2847354b4f7f3aa">cy_en_adccomp_adc_dc_channel_t</a> channel)</td></tr>
<tr class="memdesc:ga58d47f10546f2e39e96a129086d04123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the specified DC measurement channel.  <a href="#ga58d47f10546f2e39e96a129086d04123">More...</a><br /></td></tr>
<tr class="separator:ga58d47f10546f2e39e96a129086d04123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga176d888a6e5b3872281d6f099a8b6da1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__adccomp__function.html#ga176d888a6e5b3872281d6f099a8b6da1">Cy_ADCCOMP_SetPgaGain</a> (CyADCCOMP_Type *base, <a class="el" href="group__group__adccomp__data__structures.html#gac5222271524c59d37121da290c7499d2">cy_en_adccomp_adc_pga_gain_ctrl_t</a> gain)</td></tr>
<tr class="memdesc:ga176d888a6e5b3872281d6f099a8b6da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the PGA gain (gain factor 1 to 8) for MIC.  <a href="#ga176d888a6e5b3872281d6f099a8b6da1">More...</a><br /></td></tr>
<tr class="separator:ga176d888a6e5b3872281d6f099a8b6da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a2ed298d8909fb9933e704fd33d1d06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__adccomp__function.html#ga5a2ed298d8909fb9933e704fd33d1d06">Cy_ADCCOMP_ADC_Enable</a> (CyADCCOMP_Type *base)</td></tr>
<tr class="memdesc:ga5a2ed298d8909fb9933e704fd33d1d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable ADC for DC operation or MIC audio capture.  <a href="#ga5a2ed298d8909fb9933e704fd33d1d06">More...</a><br /></td></tr>
<tr class="separator:ga5a2ed298d8909fb9933e704fd33d1d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b665544c03a3f59bd5da9e30ea192cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__adccomp__function.html#ga9b665544c03a3f59bd5da9e30ea192cc">Cy_ADCCOMP_ADC_Start</a> (CyADCCOMP_Type *base)</td></tr>
<tr class="memdesc:ga9b665544c03a3f59bd5da9e30ea192cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triggers CIC operation for DC conversion.  <a href="#ga9b665544c03a3f59bd5da9e30ea192cc">More...</a><br /></td></tr>
<tr class="separator:ga9b665544c03a3f59bd5da9e30ea192cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac54ed804eeb736238baba8ac1a182e96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__adccomp__function.html#gac54ed804eeb736238baba8ac1a182e96">Cy_ADCCOMP_ADC_Stop</a> (CyADCCOMP_Type *base)</td></tr>
<tr class="memdesc:gac54ed804eeb736238baba8ac1a182e96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables PDM data sync and CIC filter.  <a href="#gac54ed804eeb736238baba8ac1a182e96">More...</a><br /></td></tr>
<tr class="separator:gac54ed804eeb736238baba8ac1a182e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6aaef7cdbf3c41a12d44a70ce5755a56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__adccomp__function.html#ga6aaef7cdbf3c41a12d44a70ce5755a56">Cy_ADCCOMP_ADC_InitiateDcCalibration</a> (CyADCCOMP_Type *base)</td></tr>
<tr class="memdesc:ga6aaef7cdbf3c41a12d44a70ce5755a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures ADC for DC calibration.  <a href="#ga6aaef7cdbf3c41a12d44a70ce5755a56">More...</a><br /></td></tr>
<tr class="separator:ga6aaef7cdbf3c41a12d44a70ce5755a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga207a414e213812e3708476ae30831559"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__adccomp__function.html#ga207a414e213812e3708476ae30831559">Cy_ADCCOMP_ADC_EndDcCalibration</a> (CyADCCOMP_Type *base)</td></tr>
<tr class="memdesc:ga207a414e213812e3708476ae30831559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program register to power down the ADC DC calibration mode.  <a href="#ga207a414e213812e3708476ae30831559">More...</a><br /></td></tr>
<tr class="separator:ga207a414e213812e3708476ae30831559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae468ebdf295bdf26d0f7fff8627ea2ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__adccomp__function.html#gae468ebdf295bdf26d0f7fff8627ea2ea">Cy_ADCCOMP_ADC_Disable</a> (CyADCCOMP_Type *base)</td></tr>
<tr class="memdesc:gae468ebdf295bdf26d0f7fff8627ea2ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program register to power down the ADC block.  <a href="#gae468ebdf295bdf26d0f7fff8627ea2ea">More...</a><br /></td></tr>
<tr class="separator:gae468ebdf295bdf26d0f7fff8627ea2ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14630b12a8a4702fa6d257072c9ccdfb"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__adccomp__function.html#ga14630b12a8a4702fa6d257072c9ccdfb">Cy_ADCCOMP_EnableTimer</a> (CyADCCOMP_Type *base)</td></tr>
<tr class="memdesc:ga14630b12a8a4702fa6d257072c9ccdfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the timer.  <a href="#ga14630b12a8a4702fa6d257072c9ccdfb">More...</a><br /></td></tr>
<tr class="separator:ga14630b12a8a4702fa6d257072c9ccdfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7db3b07b4ae0af85d580b9bcdf9693a3"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__adccomp__function.html#ga7db3b07b4ae0af85d580b9bcdf9693a3">Cy_ADCCOMP_DisableTimer</a> (CyADCCOMP_Type *base)</td></tr>
<tr class="memdesc:ga7db3b07b4ae0af85d580b9bcdf9693a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the timer.  <a href="#ga7db3b07b4ae0af85d580b9bcdf9693a3">More...</a><br /></td></tr>
<tr class="separator:ga7db3b07b4ae0af85d580b9bcdf9693a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga905759e636fa0ff9867b9be0d8419a33"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__adccomp__function.html#ga905759e636fa0ff9867b9be0d8419a33">Cy_ADCCOMP_SetTimerPeriod</a> (CyADCCOMP_Type *base, uint16_t period)</td></tr>
<tr class="memdesc:ga905759e636fa0ff9867b9be0d8419a33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the timer period.  <a href="#ga905759e636fa0ff9867b9be0d8419a33">More...</a><br /></td></tr>
<tr class="separator:ga905759e636fa0ff9867b9be0d8419a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98318d27b2080caaca049cbf69a0afc1"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__adccomp__function.html#ga98318d27b2080caaca049cbf69a0afc1">Cy_ADCCOMP_GetDcResult</a> (CyADCCOMP_Type const *base)</td></tr>
<tr class="memdesc:ga98318d27b2080caaca049cbf69a0afc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the DC conversion result from the CIC status register.  <a href="#ga98318d27b2080caaca049cbf69a0afc1">More...</a><br /></td></tr>
<tr class="separator:ga98318d27b2080caaca049cbf69a0afc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58152c876f5103cdb1d2713b27473db3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__adccomp__function.html#ga58152c876f5103cdb1d2713b27473db3">Cy_ADCCOMP_SetDcOffset</a> (CyADCCOMP_Type *base, int16_t offset, <a class="el" href="structcy__stc__adccomp__adc__context__t.html">cy_stc_adccomp_adc_context_t</a> *context)</td></tr>
<tr class="memdesc:ga58152c876f5103cdb1d2713b27473db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the offset value for DC measurement calibration.  <a href="#ga58152c876f5103cdb1d2713b27473db3">More...</a><br /></td></tr>
<tr class="separator:ga58152c876f5103cdb1d2713b27473db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bc5659fd6e341c116f7f833a1c9bd3a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__adccomp__function.html#ga6bc5659fd6e341c116f7f833a1c9bd3a">Cy_ADCCOMP_GetCalibrationResult</a> (CyADCCOMP_Type const *base)</td></tr>
<tr class="memdesc:ga6bc5659fd6e341c116f7f833a1c9bd3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the DC calibration offset API must be called after successful completion of DC calibration procedure.  <a href="#ga6bc5659fd6e341c116f7f833a1c9bd3a">More...</a><br /></td></tr>
<tr class="separator:ga6bc5659fd6e341c116f7f833a1c9bd3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad006cd4870bb5103abfa73ac3a7848b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__adccomp__function.html#gad006cd4870bb5103abfa73ac3a7848b7">Cy_ADCCOMP_SetDcGain</a> (int16_t gain, <a class="el" href="structcy__stc__adccomp__adc__context__t.html">cy_stc_adccomp_adc_context_t</a> *context)</td></tr>
<tr class="memdesc:gad006cd4870bb5103abfa73ac3a7848b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the gain value for DC measurement calibration.  <a href="#gad006cd4870bb5103abfa73ac3a7848b7">More...</a><br /></td></tr>
<tr class="separator:gad006cd4870bb5103abfa73ac3a7848b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga283d56657be4f65bc95369b39d0a3b15"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__adccomp__function.html#ga283d56657be4f65bc95369b39d0a3b15">Cy_ADCCOMP_CountsTo_mVolts</a> (int16_t adcCounts, <a class="el" href="structcy__stc__adccomp__adc__context__t.html">cy_stc_adccomp_adc_context_t</a> const *context)</td></tr>
<tr class="memdesc:ga283d56657be4f65bc95369b39d0a3b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the ADC output to millivolts as an int16.  <a href="#ga283d56657be4f65bc95369b39d0a3b15">More...</a><br /></td></tr>
<tr class="separator:ga283d56657be4f65bc95369b39d0a3b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ad6629ec98856fa329fc48af0663cad"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__adccomp__function.html#ga7ad6629ec98856fa329fc48af0663cad">Cy_ADCCOMP_CountsTo_uVolts</a> (int16_t adcCounts, <a class="el" href="structcy__stc__adccomp__adc__context__t.html">cy_stc_adccomp_adc_context_t</a> const *context)</td></tr>
<tr class="memdesc:ga7ad6629ec98856fa329fc48af0663cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the ADC output to microvolts as an int32.  <a href="#ga7ad6629ec98856fa329fc48af0663cad">More...</a><br /></td></tr>
<tr class="separator:ga7ad6629ec98856fa329fc48af0663cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad79b9bb61bb92ebb7c2b819bfccc08b7"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__adccomp__function.html#gad79b9bb61bb92ebb7c2b819bfccc08b7">Cy_ADCCOMP_GetStatusRegisterVal</a> (CyADCCOMP_Type const *base)</td></tr>
<tr class="memdesc:gad79b9bb61bb92ebb7c2b819bfccc08b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the ADCCOMP status register.  <a href="#gad79b9bb61bb92ebb7c2b819bfccc08b7">More...</a><br /></td></tr>
<tr class="separator:gad79b9bb61bb92ebb7c2b819bfccc08b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68d951778e1c5a5f8ad0695f5b756502"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__adccomp__function.html#ga68d951778e1c5a5f8ad0695f5b756502">Cy_ADCCOMP_EnableInterrupt</a> (CyADCCOMP_Type *base, uint32_t intrMask)</td></tr>
<tr class="memdesc:ga68d951778e1c5a5f8ad0695f5b756502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the specified interrupt bit in the interrupt mask register.  <a href="#ga68d951778e1c5a5f8ad0695f5b756502">More...</a><br /></td></tr>
<tr class="separator:ga68d951778e1c5a5f8ad0695f5b756502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga588d9e5b796f31cbab25916f334d7691"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__adccomp__function.html#ga588d9e5b796f31cbab25916f334d7691">Cy_ADCCOMP_DisableInterrupt</a> (CyADCCOMP_Type *base, uint32_t intrMask)</td></tr>
<tr class="memdesc:ga588d9e5b796f31cbab25916f334d7691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the specified interrupt bit in the interrupt mask register.  <a href="#ga588d9e5b796f31cbab25916f334d7691">More...</a><br /></td></tr>
<tr class="separator:ga588d9e5b796f31cbab25916f334d7691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98e41ffaa49e8a97bb3085fea0c566ef"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__adccomp__function.html#ga98e41ffaa49e8a97bb3085fea0c566ef">Cy_ADCCOMP_GetInterruptStatus</a> (CyADCCOMP_Type const *base)</td></tr>
<tr class="memdesc:ga98e41ffaa49e8a97bb3085fea0c566ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the interrupt status.  <a href="#ga98e41ffaa49e8a97bb3085fea0c566ef">More...</a><br /></td></tr>
<tr class="separator:ga98e41ffaa49e8a97bb3085fea0c566ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79e93037d5e7994fc6b1621ca65bef66"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__adccomp__function.html#ga79e93037d5e7994fc6b1621ca65bef66">Cy_ADCCOMP_ClearInterrupt</a> (CyADCCOMP_Type *base, UINT32 intrMask)</td></tr>
<tr class="memdesc:ga79e93037d5e7994fc6b1621ca65bef66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the specified interrupts status.  <a href="#ga79e93037d5e7994fc6b1621ca65bef66">More...</a><br /></td></tr>
<tr class="separator:ga79e93037d5e7994fc6b1621ca65bef66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad34b549d537381db09122e9eb44988ff"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__adccomp__function.html#gad34b549d537381db09122e9eb44988ff">Cy_ADCCOMP_GetInterruptMask</a> (CyADCCOMP_Type const *base)</td></tr>
<tr class="memdesc:gad34b549d537381db09122e9eb44988ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the interrupt mask value.  <a href="#gad34b549d537381db09122e9eb44988ff">More...</a><br /></td></tr>
<tr class="separator:gad34b549d537381db09122e9eb44988ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80d7a6d8ba2a5bc5d7065fd3fa22bbac"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__adccomp__function.html#ga80d7a6d8ba2a5bc5d7065fd3fa22bbac">Cy_ADCCOMP_SetInterrupt</a> (CyADCCOMP_Type *base, uint32_t intrMask)</td></tr>
<tr class="memdesc:ga80d7a6d8ba2a5bc5d7065fd3fa22bbac"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the interrupt.  <a href="#ga80d7a6d8ba2a5bc5d7065fd3fa22bbac">More...</a><br /></td></tr>
<tr class="separator:ga80d7a6d8ba2a5bc5d7065fd3fa22bbac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee7d1243f4b0a0abdd5650ef032406c8"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__adccomp__function.html#gaee7d1243f4b0a0abdd5650ef032406c8">Cy_ADCCOMP_SetInterruptMask</a> (CyADCCOMP_Type *base, uint32_t intrMask)</td></tr>
<tr class="memdesc:gaee7d1243f4b0a0abdd5650ef032406c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write interrupt mask value into interrupt mask register.  <a href="#gaee7d1243f4b0a0abdd5650ef032406c8">More...</a><br /></td></tr>
<tr class="separator:gaee7d1243f4b0a0abdd5650ef032406c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa078db7aafe8a4c46c4c9f330e3457e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__adccomp__function.html#gafa078db7aafe8a4c46c4c9f330e3457e">Cy_ADCCOMP_GetInterruptStatusMasked</a> (CyADCCOMP_Type const *base)</td></tr>
<tr class="memdesc:gafa078db7aafe8a4c46c4c9f330e3457e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logical AND of the corresponding INTR and INTR_MASK fields in a single-load operation.  <a href="#gafa078db7aafe8a4c46c4c9f330e3457e">More...</a><br /></td></tr>
<tr class="separator:gafa078db7aafe8a4c46c4c9f330e3457e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac17b1ba3879916125637ae27d9d6452e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__adccomp__function.html#gac17b1ba3879916125637ae27d9d6452e">Cy_ADCCOMP_RegisterIntrCallback</a> (<a class="el" href="group__group__adccomp__data__structures.html#ga65de33256b0db8e52a5be253f15d62c5">CY_ADCCOMP_IRQ_THREAD_CB_t</a> pCb)</td></tr>
<tr class="memdesc:gac17b1ba3879916125637ae27d9d6452e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the status of registration of callback for ADCCOMP IRQ <a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a>.  <a href="#gac17b1ba3879916125637ae27d9d6452e">More...</a><br /></td></tr>
<tr class="separator:gac17b1ba3879916125637ae27d9d6452e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga21da9dedd2be45f08e7d8599f345689a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a> Cy_ADCCOMP_LPCOMP_Init </td>
          <td>(</td>
          <td class="paramtype">CyADCCOMP_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__adccomp__data__structures.html#ga4f527f373ce27e67a7a13aab90b9df26">cy_en_adccomp_lpcomp_id_t</a>&#160;</td>
          <td class="paramname"><em>lpcompId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__adccomp__data__structures.html#ga66b412bde45d12e19b117f987a402dd7">cy_en_adccomp_lpcomp_mode_t</a>&#160;</td>
          <td class="paramname"><em>lpcompMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__adccomp__lpcomp__config__t.html">cy_stc_adccomp_lpcomp_config_t</a> *&#160;</td>
          <td class="paramname"><em>pCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures Low power comparator for DC mode or noise threshold detect(NTD) mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the hardware ADCCOMP block.</td></tr>
    <tr><td class="paramname">lpcompId</td><td>Low power comparator Id <a class="el" href="group__group__adccomp__data__structures.html#ga4f527f373ce27e67a7a13aab90b9df26">cy_en_adccomp_lpcomp_id_t</a>.</td></tr>
    <tr><td class="paramname">lpcompMode</td><td>Low power comparator mode of operation <a class="el" href="group__group__adccomp__data__structures.html#ga66b412bde45d12e19b117f987a402dd7">cy_en_adccomp_lpcomp_mode_t</a>.</td></tr>
    <tr><td class="paramname">pCfg</td><td>The pointer to the configuration structure <a class="el" href="structcy__stc__adccomp__lpcomp__config__t.html">cy_stc_adccomp_lpcomp_config_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status <a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gad88fc0bab64965cbea93facd34aa8576"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a> Cy_ADCCOMP_LPCOMP_Enable </td>
          <td>(</td>
          <td class="paramtype">CyADCCOMP_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__adccomp__data__structures.html#ga4f527f373ce27e67a7a13aab90b9df26">cy_en_adccomp_lpcomp_id_t</a>&#160;</td>
          <td class="paramname"><em>lpcompId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable comparator for either DC threshold detection or NTD(Noise Threshold mode). </p>
<p>when comparator i/p(i.e. +ve terminal i/p) is above threshold(i.e. -ve terminal value), comparator interrupt group_adccomp_macros_interrupt get generated. In interrupt callback, ADC status register <a class="el" href="group__group__adccomp__data__structures.html#gabac64d303ae1e0dd34c8adfdcc23d247">cy_adccomp_status_register_mask_t</a> can be read to check for comparator o/p latched high.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the hardware ADCCOMP block.</td></tr>
    <tr><td class="paramname">lpcompId</td><td>Low power comparator Id <a class="el" href="group__group__adccomp__data__structures.html#ga4f527f373ce27e67a7a13aab90b9df26">cy_en_adccomp_lpcomp_id_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status <a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>if comparator configured for NTD mode and enabling, application must wait for comparator to settle and configure as wake source using /ref Cy_ADCCOMP_LPCOMP_EnableWakeConfig what is comparator settling? When comparator configured for NTD mode first time after power up, it take a while for comparator to settle down depending on DC blocking capacitor and MIC output common-mode (DC output), both are application configurable. During this time comparator may latch if the voltage difference between comparator +ve and -ve terminal exceed configured hysterisis limit. Application needs to poll for every 10 ms for comparator latched status using /ref Cy_ADCCOMP_GetStatusRegisterVal and clear latch using /ref Cy_ADCCOMP_GetStatusRegisterVal. Once application does not see comparator latch, few 10 ms intervals continuously then application configure comparator as wake source using /ref Cy_ADCCOMP_LPCOMP_EnableWakeConfig and then only allow device to enter to low power mode. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7b430d444c4f7492cc73084bfd3b828f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a> Cy_ADCCOMP_LPCOMP_Disable </td>
          <td>(</td>
          <td class="paramtype">CyADCCOMP_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__adccomp__data__structures.html#ga4f527f373ce27e67a7a13aab90b9df26">cy_en_adccomp_lpcomp_id_t</a>&#160;</td>
          <td class="paramname"><em>lpcompId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables comparator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the hardware ADCCOMP block.</td></tr>
    <tr><td class="paramname">lpcompId</td><td>Low power comparator Id <a class="el" href="group__group__adccomp__data__structures.html#ga4f527f373ce27e67a7a13aab90b9df26">cy_en_adccomp_lpcomp_id_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status <a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0e743e28b37cf95fb7af12f792f36878"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a> Cy_ADCCOMP_LPCOMP_DeInit </td>
          <td>(</td>
          <td class="paramtype">CyADCCOMP_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__adccomp__data__structures.html#ga4f527f373ce27e67a7a13aab90b9df26">cy_en_adccomp_lpcomp_id_t</a>&#160;</td>
          <td class="paramname"><em>lpcompId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable comparator and resets configuration to default values, i.e. </p>
<p>input to comparator is open, Resets comparator o/p, Clears NTD mode and Set Hysterisis to CY_LPCOMP_HYST_LIMIT_0MV_NONE</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the hardware ADCCOMP block.</td></tr>
    <tr><td class="paramname">lpcompId</td><td>Low power comparator Id <a class="el" href="group__group__adccomp__data__structures.html#ga4f527f373ce27e67a7a13aab90b9df26">cy_en_adccomp_lpcomp_id_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status <a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gabca5ed32c461f0ac0af14b315ecdd076"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_ADCCOMP_LPCOMP_EnableWakeConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__adccomp__data__structures.html#ga4f527f373ce27e67a7a13aab90b9df26">cy_en_adccomp_lpcomp_id_t</a>&#160;</td>
          <td class="paramname"><em>lpcompId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures comparator as wake source. </p>
<p>Applicable to use in NTD mode only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lpcompId</td><td>Low power comparator Id <a class="el" href="group__group__adccomp__data__structures.html#ga4f527f373ce27e67a7a13aab90b9df26">cy_en_adccomp_lpcomp_id_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function must be called after comparator settled down after comparator configured for NTD mode. /ref Cy_ADCCOMP_LPCOMP_Enable description </dd></dl>

</div>
</div>
<a class="anchor" id="gaa63cee1c4bced8486ce2ecccf5fc9099"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_ADCCOMP_LPCOMP_DisableWakeConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__adccomp__data__structures.html#ga4f527f373ce27e67a7a13aab90b9df26">cy_en_adccomp_lpcomp_id_t</a>&#160;</td>
          <td class="paramname"><em>lpcompId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables comparator wake source configuration. </p>
<p>Applicable to use in NTD mode only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lpcompId</td><td>Low power comparator Id <a class="el" href="group__group__adccomp__data__structures.html#ga4f527f373ce27e67a7a13aab90b9df26">cy_en_adccomp_lpcomp_id_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4a1d784ae85536473f28303581038aa8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a> Cy_ADCCOMP_LPCOMP_ClearLatch </td>
          <td>(</td>
          <td class="paramtype">CyADCCOMP_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__adccomp__data__structures.html#ga4f527f373ce27e67a7a13aab90b9df26">cy_en_adccomp_lpcomp_id_t</a>&#160;</td>
          <td class="paramname"><em>lpcompId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the comparator latched status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the hardware ADCCOMP block.</td></tr>
    <tr><td class="paramname">lpcompId</td><td>Low power comparator Id <a class="el" href="group__group__adccomp__data__structures.html#ga4f527f373ce27e67a7a13aab90b9df26">cy_en_adccomp_lpcomp_id_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status <a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga708ca74f75b3729b5327b646799db887"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a> Cy_ADCCOMP_ADC_Init </td>
          <td>(</td>
          <td class="paramtype">CyADCCOMP_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__adccomp__data__structures.html#gaf20680e29db015c9b65df5ff276cfd0a">cy_en_adccomp_adc_mode_t</a>&#160;</td>
          <td class="paramname"><em>adcMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__adccomp__adc__config__t.html">cy_stc_adccomp_adc_config_t</a> *&#160;</td>
          <td class="paramname"><em>pCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures ADC block for DC conversion or analog MIC mode for audio acquistion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the hardware ADCCOMP block.</td></tr>
    <tr><td class="paramname">adcMode</td><td>ADC mode of operation <a class="el" href="group__group__adccomp__data__structures.html#gaf20680e29db015c9b65df5ff276cfd0a">cy_en_adccomp_adc_mode_t</a>.</td></tr>
    <tr><td class="paramname">pCfg</td><td>The pointer to the configuration structure <a class="el" href="structcy__stc__adccomp__adc__config__t.html">cy_stc_adccomp_adc_config_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status <a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga58d47f10546f2e39e96a129086d04123"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a> Cy_ADCCOMP_ADC_SelectDcChannel </td>
          <td>(</td>
          <td class="paramtype">CyADCCOMP_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__adccomp__data__structures.html#ga5d18e36866381d90b2847354b4f7f3aa">cy_en_adccomp_adc_dc_channel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the specified DC measurement channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the hardware ADCCOMP block.</td></tr>
    <tr><td class="paramname">channel</td><td>The DC measurement channel <a class="el" href="group__group__adccomp__data__structures.html#ga5d18e36866381d90b2847354b4f7f3aa">cy_en_adccomp_adc_dc_channel_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is useful for DC measurement only.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The status <a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga176d888a6e5b3872281d6f099a8b6da1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a> Cy_ADCCOMP_SetPgaGain </td>
          <td>(</td>
          <td class="paramtype">CyADCCOMP_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__adccomp__data__structures.html#gac5222271524c59d37121da290c7499d2">cy_en_adccomp_adc_pga_gain_ctrl_t</a>&#160;</td>
          <td class="paramname"><em>gain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the PGA gain (gain factor 1 to 8) for MIC. </p>
<p>In DC mode, gain not applicable, i.e gain = 1. This API must be called before ADC enabled</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the hardware ADCCOMP block.</td></tr>
    <tr><td class="paramname">gain</td><td>The gain value <a class="el" href="group__group__adccomp__data__structures.html#gac5222271524c59d37121da290c7499d2">cy_en_adccomp_adc_pga_gain_ctrl_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status <a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5a2ed298d8909fb9933e704fd33d1d06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a> Cy_ADCCOMP_ADC_Enable </td>
          <td>(</td>
          <td class="paramtype">CyADCCOMP_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable ADC for DC operation or MIC audio capture. </p>
<p>CY_ADCCOMP_INTR_ADC_READY group_adccomp_macros_interrupt interrupt get generated, on ADC LDO stable(i.e. ADC ready for operation). From interrupt callback, call below APIs for corresponding operation. DC mode: DC conversion: Call Cy_ADCCOMP_ADC_Start for DC conversion DC calibration: Call Cy_ADCCOMP_ADC_InitiateDcCalibration MIC audio capture: call pdmpcm APIs cy_pdm_pcm.h to capture PCM audio samples</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the hardware ADCCOMP block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status <a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9b665544c03a3f59bd5da9e30ea192cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a> Cy_ADCCOMP_ADC_Start </td>
          <td>(</td>
          <td class="paramtype">CyADCCOMP_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Triggers CIC operation for DC conversion. </p>
<p>CY_ADCCOMP_INTR_CIC group_adccomp_macros_interrupt interrupt get generated on CIC operation completion. From interrupt callback, call corresponding APIs to get DC result. For DC calibration value, call Cy_ADCCOMP_GetDcOffset to get signed DCc alibration result. User has to save this value in memory <a class="el" href="structcy__stc__adccomp__adc__context__t.html">cy_stc_adccomp_adc_context_t</a> and use it in subsequent DC measures.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the hardware ADCCOMP block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status <a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gac54ed804eeb736238baba8ac1a182e96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a> Cy_ADCCOMP_ADC_Stop </td>
          <td>(</td>
          <td class="paramtype">CyADCCOMP_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables PDM data sync and CIC filter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the hardware ADCCOMP block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status <a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6aaef7cdbf3c41a12d44a70ce5755a56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a> Cy_ADCCOMP_ADC_InitiateDcCalibration </td>
          <td>(</td>
          <td class="paramtype">CyADCCOMP_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures ADC for DC calibration. </p>
<p>CY_ADCCOMP_INTR_ADC_READY group_adccomp_macros_interrupt interrupt get generated From interrupt callback, call Cy_ADCCOMP_ADC_Start to start CIC operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the hardware ADCCOMP block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status <a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga207a414e213812e3708476ae30831559"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_ADCCOMP_ADC_EndDcCalibration </td>
          <td>(</td>
          <td class="paramtype">CyADCCOMP_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Program register to power down the ADC DC calibration mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the hardware ADCCOMP block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae468ebdf295bdf26d0f7fff8627ea2ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a> Cy_ADCCOMP_ADC_Disable </td>
          <td>(</td>
          <td class="paramtype">CyADCCOMP_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Program register to power down the ADC block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the hardware ADCCOMP block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status <a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga14630b12a8a4702fa6d257072c9ccdfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_ADCCOMP_EnableTimer </td>
          <td>(</td>
          <td class="paramtype">CyADCCOMP_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the timer. </p>
<p><a class="el" href="group__group__adccomp__function.html#ga905759e636fa0ff9867b9be0d8419a33">Cy_ADCCOMP_SetTimerPeriod</a> for timer requirement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the hardware ADCCOMP block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7db3b07b4ae0af85d580b9bcdf9693a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_ADCCOMP_DisableTimer </td>
          <td>(</td>
          <td class="paramtype">CyADCCOMP_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the hardware ADCCOMP block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga905759e636fa0ff9867b9be0d8419a33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_ADCCOMP_SetTimerPeriod </td>
          <td>(</td>
          <td class="paramtype">CyADCCOMP_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the timer period. </p>
<p>Timer control APIs allows the user to give extra time to ADC LDO to become stable. By default driver bypass the timer and relay on ADC's GMLDO OK signal to generate CY_ADCCOMP_INTR_ADC_READY group_adccomp_macros_interrupt. For examle, at 2.048Mhz default value(= 0xCD) count will be programmed to generate CY_ADCCOMP_INTR_ADC_READY interrupt based on ADC GM LDO OK signal to indicate that 100us has lapsed and the ADC's LDO is stable. User can adjust this count through external timer using these APIs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the hardware ADCCOMP block.</td></tr>
    <tr><td class="paramname">period</td><td>The 16-bit timer period. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga98318d27b2080caaca049cbf69a0afc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE int16_t Cy_ADCCOMP_GetDcResult </td>
          <td>(</td>
          <td class="paramtype">CyADCCOMP_Type const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the DC conversion result from the CIC status register. </p>
<p>Note:- Driver programs HW to get calibrated DC conversion result, so user must program valid calibration offset value using <a class="el" href="group__group__adccomp__function.html#ga58152c876f5103cdb1d2713b27473db3" title="Sets the offset value for DC measurement calibration. ">Cy_ADCCOMP_SetDcOffset</a> before start DC measurement operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the hardware ADCCOMP block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The signed DC conversion result. </dd></dl>

</div>
</div>
<a class="anchor" id="ga58152c876f5103cdb1d2713b27473db3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_ADCCOMP_SetDcOffset </td>
          <td>(</td>
          <td class="paramtype">CyADCCOMP_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__adccomp__adc__context__t.html">cy_stc_adccomp_adc_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the offset value for DC measurement calibration. </p>
<p>HW CIC updated with offset value</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the hardware ADCCOMP block.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset value.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__adccomp__adc__context__t.html">cy_stc_adccomp_adc_context_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6bc5659fd6e341c116f7f833a1c9bd3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE int16_t Cy_ADCCOMP_GetCalibrationResult </td>
          <td>(</td>
          <td class="paramtype">CyADCCOMP_Type const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the DC calibration offset API must be called after successful completion of DC calibration procedure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the hardware ADCCOMP block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The signed DC calibration result. </dd></dl>

</div>
</div>
<a class="anchor" id="gad006cd4870bb5103abfa73ac3a7848b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_ADCCOMP_SetDcGain </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__adccomp__adc__context__t.html">cy_stc_adccomp_adc_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the gain value for DC measurement calibration. </p>
<p>For H1 ADCCOMP IP, this is 2 ^ 15 = 0x8000, essentially it is an amount of raw counts per 1 volt of input voltage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gain</td><td>The gain value.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__adccomp__adc__context__t.html">cy_stc_adccomp_adc_context_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga283d56657be4f65bc95369b39d0a3b15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE int16_t Cy_ADCCOMP_CountsTo_mVolts </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>adcCounts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__adccomp__adc__context__t.html">cy_stc_adccomp_adc_context_t</a> const *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the ADC output to millivolts as an int16. </p>
<p>For example, if the ADC measured 0.534 volts, the return value would be 534. The calculation of voltage depends on the DC range. The equation used is: </p><pre class="fragment">mV = (RawCounts) * 1000 / Gain
</pre><p>where,</p><ul>
<li>RawCounts: Raw counts returned by the <a class="el" href="group__group__adccomp__function.html#ga98318d27b2080caaca049cbf69a0afc1">Cy_ADCCOMP_GetDcResult</a>.</li>
<li>Driver programs the hardware to adjust Raw counts by the <a class="el" href="group__group__adccomp__function.html#ga58152c876f5103cdb1d2713b27473db3">Cy_ADCCOMP_SetDcOffset</a>, essentially it is a raw count value of ADC internal ground voltage measurement.</li>
<li>1000 * - amount of millivolts in 1 volt</li>
<li>Gain: the gain value, can be adjusted by the <a class="el" href="group__group__adccomp__function.html#gad006cd4870bb5103abfa73ac3a7848b7">Cy_ADCCOMP_SetDcGain</a>, depends on DC range, essentially it is an amount of raw counts per 1 volt of input voltage.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This function is for DC measurement only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adcCounts</td><td>Conversion result from <a class="el" href="group__group__adccomp__function.html#ga98318d27b2080caaca049cbf69a0afc1">Cy_ADCCOMP_GetDcResult</a></td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__adccomp__adc__context__t.html">cy_stc_adccomp_adc_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result in millivolts. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7ad6629ec98856fa329fc48af0663cad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE int32_t Cy_ADCCOMP_CountsTo_uVolts </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>adcCounts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__adccomp__adc__context__t.html">cy_stc_adccomp_adc_context_t</a> const *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the ADC output to microvolts as an int32. </p>
<p>For example, if the ADC measured 0.534 volts, the return value would be 534000. The calculation of voltage depends on the DC range. The equation used is: </p><pre class="fragment">uV = (RawCounts) * 1000000 / Gain
</pre><p>where,</p><ul>
<li>RawCounts: Raw counts returned by the <a class="el" href="group__group__adccomp__function.html#ga98318d27b2080caaca049cbf69a0afc1">Cy_ADCCOMP_GetDcResult</a>.</li>
<li>Driver programs the hardware to adjust Raw counts by the <a class="el" href="group__group__adccomp__function.html#ga58152c876f5103cdb1d2713b27473db3">Cy_ADCCOMP_SetDcOffset</a>, essentially it is a raw count value of ADC internal ground voltage measurement.</li>
<li>1000000 - amount of microvolts in 1 volt</li>
<li>Gain: the gain value, can be adjusted by the <a class="el" href="group__group__adccomp__function.html#gad006cd4870bb5103abfa73ac3a7848b7">Cy_ADCCOMP_SetDcGain</a>, depends on DC range, essentially it is an amount of raw counts per 1 volt of input voltage.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This function is for DC measurement only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adcCounts</td><td>Conversion result from <a class="el" href="group__group__adccomp__function.html#ga98318d27b2080caaca049cbf69a0afc1">Cy_ADCCOMP_GetDcResult</a></td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the context structure <a class="el" href="structcy__stc__adccomp__adc__context__t.html">cy_stc_adccomp_adc_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result in microvolts. </dd></dl>

</div>
</div>
<a class="anchor" id="gad79b9bb61bb92ebb7c2b819bfccc08b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE UINT32 Cy_ADCCOMP_GetStatusRegisterVal </td>
          <td>(</td>
          <td class="paramtype">CyADCCOMP_Type const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the ADCCOMP status register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the hardware ADCCOMP block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ADC Status register value <a class="el" href="group__group__adccomp__data__structures.html#gabac64d303ae1e0dd34c8adfdcc23d247">cy_adccomp_status_register_mask_t</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga68d951778e1c5a5f8ad0695f5b756502"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_ADCCOMP_EnableInterrupt </td>
          <td>(</td>
          <td class="paramtype">CyADCCOMP_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the specified interrupt bit in the interrupt mask register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the hardware ADCCOMP block.</td></tr>
    <tr><td class="paramname">intrMask</td><td>The mask of interrupts. Select one or more values from group_adccomp_macros_interrupt and "OR" them together.<ul>
<li><a class="el" href="group__group__adccomp__macros.html#ga142e6d40bca8d1193ed894a8645e7616">CY_ADCCOMP_INTR_LPCOMP1</a></li>
<li><a class="el" href="group__group__adccomp__macros.html#gacf7648923dc948bb6a4d8b6eb68bbb34">CY_ADCCOMP_INTR_LPCOMP2</a></li>
<li><a class="el" href="group__group__adccomp__macros.html#ga9e5c6bbf775f16c5a9aec40c4efb7cca">CY_ADCCOMP_INTR_CIC</a></li>
<li><a class="el" href="group__group__adccomp__macros.html#ga831e392c7595b1a28111a0d66d396f52">CY_ADCCOMP_INTR_ADC_READY</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga588d9e5b796f31cbab25916f334d7691"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_ADCCOMP_DisableInterrupt </td>
          <td>(</td>
          <td class="paramtype">CyADCCOMP_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the specified interrupt bit in the interrupt mask register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the hardware ADCCOMP block.</td></tr>
    <tr><td class="paramname">intrMask</td><td>The mask of interrupts. Select one or more values from group_adccomp_macros_interrupt and "OR" them together.<ul>
<li><a class="el" href="group__group__adccomp__macros.html#ga142e6d40bca8d1193ed894a8645e7616">CY_ADCCOMP_INTR_LPCOMP1</a></li>
<li><a class="el" href="group__group__adccomp__macros.html#gacf7648923dc948bb6a4d8b6eb68bbb34">CY_ADCCOMP_INTR_LPCOMP2</a></li>
<li><a class="el" href="group__group__adccomp__macros.html#ga9e5c6bbf775f16c5a9aec40c4efb7cca">CY_ADCCOMP_INTR_CIC</a></li>
<li><a class="el" href="group__group__adccomp__macros.html#ga831e392c7595b1a28111a0d66d396f52">CY_ADCCOMP_INTR_ADC_READY</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga98e41ffaa49e8a97bb3085fea0c566ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE UINT32 Cy_ADCCOMP_GetInterruptStatus </td>
          <td>(</td>
          <td class="paramtype">CyADCCOMP_Type const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the interrupt status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the hardware ADCCOMP block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interrupt status. </dd></dl>

</div>
</div>
<a class="anchor" id="ga79e93037d5e7994fc6b1621ca65bef66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_ADCCOMP_ClearInterrupt </td>
          <td>(</td>
          <td class="paramtype">CyADCCOMP_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>intrMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the specified interrupts status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the hardware ADCCOMP block.</td></tr>
    <tr><td class="paramname">intrMask</td><td>The mask of interrupts to clear. Typically this will be the value returned from <a class="el" href="group__group__adccomp__function.html#ga98e41ffaa49e8a97bb3085fea0c566ef">Cy_ADCCOMP_GetInterruptStatus</a>. Alternately, select one or more values from group_adccomp_macros_interrupt and "OR" them together.<ul>
<li><a class="el" href="group__group__adccomp__macros.html#ga142e6d40bca8d1193ed894a8645e7616">CY_ADCCOMP_INTR_LPCOMP1</a></li>
<li><a class="el" href="group__group__adccomp__macros.html#gacf7648923dc948bb6a4d8b6eb68bbb34">CY_ADCCOMP_INTR_LPCOMP2</a></li>
<li><a class="el" href="group__group__adccomp__macros.html#ga9e5c6bbf775f16c5a9aec40c4efb7cca">CY_ADCCOMP_INTR_CIC</a></li>
<li><a class="el" href="group__group__adccomp__macros.html#ga831e392c7595b1a28111a0d66d396f52">CY_ADCCOMP_INTR_ADC_READY</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad34b549d537381db09122e9eb44988ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE UINT32 Cy_ADCCOMP_GetInterruptMask </td>
          <td>(</td>
          <td class="paramtype">CyADCCOMP_Type const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the interrupt mask value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the hardware ADCCOMP block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interrupt mask value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga80d7a6d8ba2a5bc5d7065fd3fa22bbac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_ADCCOMP_SetInterrupt </td>
          <td>(</td>
          <td class="paramtype">CyADCCOMP_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets the interrupt. </p>
<p>Intended mostly for debugging.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the hardware ADCCOMP block.</td></tr>
    <tr><td class="paramname">intrMask</td><td>The mask of interrupts. Select one or more values from group_adccomp_macros_interrupt and "OR" them together.<ul>
<li><a class="el" href="group__group__adccomp__macros.html#ga142e6d40bca8d1193ed894a8645e7616">CY_ADCCOMP_INTR_LPCOMP1</a></li>
<li><a class="el" href="group__group__adccomp__macros.html#gacf7648923dc948bb6a4d8b6eb68bbb34">CY_ADCCOMP_INTR_LPCOMP2</a></li>
<li><a class="el" href="group__group__adccomp__macros.html#ga9e5c6bbf775f16c5a9aec40c4efb7cca">CY_ADCCOMP_INTR_CIC</a></li>
<li><a class="el" href="group__group__adccomp__macros.html#ga831e392c7595b1a28111a0d66d396f52">CY_ADCCOMP_INTR_ADC_READY</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaee7d1243f4b0a0abdd5650ef032406c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_ADCCOMP_SetInterruptMask </td>
          <td>(</td>
          <td class="paramtype">CyADCCOMP_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write interrupt mask value into interrupt mask register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the hardware ADCCOMP block. CyADCCOMP_Type</td></tr>
    <tr><td class="paramname">intrMask</td><td>The mask of interrupts. Select one or more values from group_adccomp_macros_interrupt and "OR" them together.<ul>
<li><a class="el" href="group__group__adccomp__macros.html#ga142e6d40bca8d1193ed894a8645e7616">CY_ADCCOMP_INTR_LPCOMP1</a></li>
<li><a class="el" href="group__group__adccomp__macros.html#gacf7648923dc948bb6a4d8b6eb68bbb34">CY_ADCCOMP_INTR_LPCOMP2</a></li>
<li><a class="el" href="group__group__adccomp__macros.html#ga9e5c6bbf775f16c5a9aec40c4efb7cca">CY_ADCCOMP_INTR_CIC</a></li>
<li><a class="el" href="group__group__adccomp__macros.html#ga831e392c7595b1a28111a0d66d396f52">CY_ADCCOMP_INTR_ADC_READY</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafa078db7aafe8a4c46c4c9f330e3457e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_ADCCOMP_GetInterruptStatusMasked </td>
          <td>(</td>
          <td class="paramtype">CyADCCOMP_Type const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the logical AND of the corresponding INTR and INTR_MASK fields in a single-load operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the hardware ADCCOMP block. CyADCCOMP_Type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The masked interrupt status. </dd></dl>

</div>
</div>
<a class="anchor" id="gac17b1ba3879916125637ae27d9d6452e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a> Cy_ADCCOMP_RegisterIntrCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__adccomp__data__structures.html#ga65de33256b0db8e52a5be253f15d62c5">CY_ADCCOMP_IRQ_THREAD_CB_t</a>&#160;</td>
          <td class="paramname"><em>pCb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the status of registration of callback for ADCCOMP IRQ <a class="el" href="group__group__adccomp__data__structures.html#ga8589d7049de90160f17acf46285c2599">cy_en_adccomp_status_t</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCb</td><td>Callback for ADCCOMP IRQ to application <a class="el" href="group__group__adccomp__data__structures.html#ga65de33256b0db8e52a5be253f15d62c5">CY_ADCCOMP_IRQ_THREAD_CB_t</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>MTB CAT5 Peripheral driver library</b> by <b>Infineon Technologies</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
