<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MTB CAT5 Peripheral driver library: Getting Started</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.infineon.com/"><img alt="Logo" src="IFX_LOGO_RGB.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MTB CAT5 Peripheral driver library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li><a href="page_getting_started.html"><span>Getting&#160;started</span></a></li>
      <li><a href="modules.html"><span>PDL&#160;API&#160;Reference</span></a></li>
      <li><a href="usergroup0.html"><span>Online&#160;Documentation</span></a></li>
      <li><a href="usergroup1.html"><span>Device&#160;Catalog</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)"
               onblur="searchBox.OnSearchFieldFocus(false)"
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('page_getting_started.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0"
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Getting Started </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>PDL depends on the Core Library. Download it from <a href="https://github.com/Infineon/core-lib">https://github.com/Infineon/core-lib</a> and add cy_utils.h to the include search path.</p>
<p>Include cy_pdl.h in your source code to use PDL.</p>
<p>To successfully develop software for the CAT5 family of devices, you must configure the peripherals to implement desired behavior. In addition, you must configure clocks, GPIO, and interrupts, as well as route signals from one peripheral to another.</p>
<p>This introduction covers some high level concepts that help you understand and use the PDL to accomplish these tasks. The topics are:</p><ul>
<li><a class="el" href="page_getting_started.html#page_getting_started_pdl_overview">PDL Overview</a></li>
<li><a class="el" href="page_getting_started.html#page_getting_started_pdl_design">PDL Design</a></li>
<li><a class="el" href="page_getting_started.html#page_getting_started_memory_allocation">Memory Allocation</a></li>
</ul>
<p>This PDL API Reference covers the peripheral drivers. Documentation on other parts of the overall software development kit are in there respective references, such as the Bootloader SDK API Reference and the BLE API Reference.</p>
<p><a class="anchor" id="page_getting_started_pdl_overview"></a></p><h1>PDL Overview</h1>
<p>PDL is the software development kit for the CAT5 family of devices. Although called the Peripheral Driver Library it contains much more than driver source code.</p>
<p>The PDL occupies the space between application code and the hardware IP blocks (peripherals). It provides driver source code you use to customize drivers for an application. To see the exact list of available drivers, expand the PDL API Reference in the left menu. It also includes all required device-specific header and startup files.</p>
<p>The PDL manages all register access. This reduces the need to understand register usage and bit fields, thus easing software development for the extensive set of peripherals provided for CAT5 devices.</p>
<p><a class="anchor" id="page_getting_started_pdl_design"></a></p><h1>PDL Design</h1>
<p>The CAT5 device CYW55500A1 uses a Cortex® M33. The hardware defines a shared register set and memory map for all peripherals.</p>
<p>The set of available peripherals varies per device. In some cases there are multiple instances of the same peripheral; for example, multiple Serial Communication Blocks (SCB). Each peripheral instance may itself operate on multiple instances of user data.</p>
<p>To enable a peripheral to be used by either or both cores, as well as multiple instances of configurable peripherals operating on (potentially) multiple instances of data, the PDL implements a simple, consistent design based on three fundamental concepts.</p>
<p><b>Base Hardware Address:</b> At the hardware level, peripheral features and behavior are controlled by registers. Each peripheral instance has a base hardware address that points to the registers for that instance. The PDL uses this base address to access the necessary registers. A device-specific header file defines the symbols for the base hardware address of each instance of each peripheral.</p>
<p>Each such file defines a symbol that represents a pointer to the base hardware address for each instance of each peripheral on the device. Use this symbol in your code. The next snippet shows the symbols for instances of the SCB peripheral on this device, which supports nine SCB instances: </p><div class="image">
<img src="getting_started_base_address.png" alt="getting_started_base_address.png"/>
</div>
<p> The header file contains similar definitions for each peripheral.</p>
<p><b>Configuration Structure:</b> Each peripheral instance is configurable. Modify values in a PDL configuration structure to change behavior to fit design requirements. The PDL then manages register access using the base hardware address.</p>
<p><b>Context Structure:</b> A PDL driver may require memory to perform operations. A driver does not allocate memory for this purpose. Firmware allocates the required memory by declaring an instance of a context structure. The address of this variable is passed in function calls. The PDL defines all necessary context structures.</p>
<p>The PDL manages the contents of the context variable. <em>Firmware does not read or write the values of the fields in a context variable.</em> In effect, firmware provides a scratch pad in memory for the PDL driver to do its work. Firmware must ensure that a context variable remains in scope when in use. Typically a context variable is declared as static, or as a global variable.</p>
<p>Many PDL API function calls require a parameter representing one or more of these three concepts. The precise details vary per peripheral, but the design is consistent. There are three commonly-named parameters in the PDL, used to support this design.</p>
<center>Common PDL Parameters</center><table  class="doxtable">
<tr>
<th>Parameter </th><th>Data Type </th><th>Purpose  </th></tr>
<tr>
<td><code>base</code> </td><td>&lt;peripheral&gt;_Type* </td><td>Base hardware address for an instance of a peripheral  </td></tr>
</table>
<p>In addition, all functions follow this naming convention: Cy_&lt;Peripheral&gt;_&lt;FunctionName&gt;().</p>
<p>Firmware must initialize and enable a driver before using it. The PDL API has functions for the purpose. Some peripherals may not implement one or more of these common functions because they aren’t needed for that particular peripheral.</p>
<center>Common PDL Functions</center><table  class="doxtable">
<tr>
<th>Name </th><th>Purpose </th><th>Example  </th></tr>
<tr>
<td>Cy_&lt;Peripheral&gt;_Init() </td><td>Initialize a peripheral, typically based on a config structure </td><td>Cy_SCB_UART_Init()  </td></tr>
<tr>
<td>Cy_&lt;Peripheral&gt;_DeInit() </td><td>de-initialize a peripheral </td><td>Cy_SCB_UART_DeInit()  </td></tr>
<tr>
<td>Cy_&lt;Peripheral&gt;_Enable() </td><td>turn on the peripheral </td><td><a class="el" href="group__group__scb__uart__general__functions.html#ga503d0737dadf35620306ef3571d84905" title="Enables the SCB block for the UART operation. ">Cy_SCB_UART_Enable()</a>  </td></tr>
<tr>
<td>Cy_&lt;Peripheral&gt;_Disable() </td><td>turn off the peripheral </td><td>Cy_SCB_UART_Disable()  </td></tr>
</table>
<p><b>Return Status Code:</b> Each driver has a unique return status enumeration type - cy_en_&lt;peripheral&gt;_status_t. The type is used by functions within the driver to indicate the return status. Drivers return success status code with a value of 0. The status code consists of the following fields:</p>
<div class="image">
<img src="getting_started_return_status_code.png" alt="getting_started_return_status_code.png"/>
</div>
<ul>
<li>The higher 14 bits identify the driver that is returning status.</li>
<li>The 2 bits after, indicates the status type: 0 for information, 1 for warning, and 2 for error.</li>
<li>The lower 16 bits contain the actual returned status.</li>
</ul>
<p>Example of return status type: </p><div class="image">
<img src="getting_started_return_status_example.png" alt="getting_started_return_status_example.png"/>
</div>
<dl class="section note"><dt>Note</dt><dd>It is possible for one driver to call another driver and return the status code from that other driver. For instance, for PSoC&trade; 64 devices the SysPm and SysClk drivers use PRA driver functionality. If there is an error in the PRA driver, the SysPm or SysClk driver may return the PRA driver status. The value returned always identifies the driver that is the source of the error. Refer to the driver description for details.</dd></dl>
<p><a class="anchor" id="page_getting_started_memory_allocation"></a></p><h1>Memory Allocation</h1>
<p>A direct effect of the context structure described in the PDL Design section is that the PDL drivers do not dynamically allocate memory. The user allocates the memory required by the driver, by declaring a context structure.</p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>MTB CAT5 Peripheral driver library</b> by <b>Infineon Technologies</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
