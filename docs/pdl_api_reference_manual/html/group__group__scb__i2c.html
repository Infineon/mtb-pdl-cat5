<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MTB CAT5 Peripheral driver library: I2C (SCB)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.infineon.com/"><img alt="Logo" src="IFX_LOGO_RGB.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MTB CAT5 Peripheral driver library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li><a href="page_getting_started.html"><span>Getting&#160;started</span></a></li>
      <li><a href="modules.html"><span>PDL&#160;API&#160;Reference</span></a></li>
      <li><a href="usergroup0.html"><span>Online&#160;Documentation</span></a></li>
      <li><a href="usergroup1.html"><span>Device&#160;Catalog</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)"
               onblur="searchBox.OnSearchFieldFocus(false)"
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__scb__i2c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0"
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">API Reference</a>  </div>
  <div class="headertitle">
<div class="title">I2C (SCB)<div class="ingroups"><a class="el" href="group__group__scb.html">SCB          (Serial Communication Block)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p>Driver API for I2C Bus Peripheral. </p>
<p>I2C - The Inter-Integrated Circuit (I2C) bus is an industry-standard.</p>
<p>The functions and other declarations used in this part of the driver are in cy_scb_i2c.h. You can also include cy_pdl.h to get access to all functions and declarations in the PDL.</p>
<p>The I2C peripheral driver provides an API to implement I2C slave, master, or master-slave devices based on the SCB hardware block. I2C devices based on SCB hardware are compatible with I2C Standard-mode, Fast-mode, and Fast-mode Plus specifications as defined in the I2C-bus specification.</p>
<p>Features:</p><ul>
<li>An industry-standard I2C bus interface</li>
<li>Supports slave, master, and master-slave operation</li>
<li>Supports standard data rates of 100/400/1000 kbps</li>
<li>Hardware Address Match, multiple addresses</li>
<li>Wake from Deep Sleep on Address Match</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>I2C supports clock stretching. This occurs when a slave device is not capable of processing data, it holds the SCL line by driving a '0'. The master device monitors the SCL line and detects it when it cannot generate a positive clock pulse ('1') on the SCL line. It then reacts by delaying the generation of a positive edge on the SCL line, effectively synchronizing with the slave device that is stretching the clock. Clock stretching can occur in the case of externally clocked address matching until the internally clocked logic takes over. The largest reason for clock stretching is when the master tries to write to the slave and the slave's RX FIFO is full, the slave will then clock stretch until the FIFO is no longer full. For more information on FIFO size and clock stretching see the architecture TRM.</dd></dl>
<h1><a class="anchor" id="group_scb_i2c_configuration"></a>
Configuration Considerations</h1>
<p>The I2C driver configuration can be divided to number of sequential steps listed below:</p><ul>
<li><a class="el" href="group__group__scb__i2c.html#group_scb_i2c_config">Configure I2C</a></li>
<li><a class="el" href="group__group__scb__i2c.html#group_scb_i2c_pins">Assign and Configure Pins</a></li>
<li><a class="el" href="group__group__scb__i2c.html#group_scb_i2c_clock">Assign Clock Divider</a></li>
<li><a class="el" href="group__group__scb__i2c.html#group_scb_i2c_data_rate">Configure Data Rate</a></li>
<li><a class="el" href="group__group__scb__i2c.html#group_scb_i2c_intr">Configure Interrupt</a></li>
<li><a class="el" href="group__group__scb__i2c.html#group_scb_i2c_enable">Enable I2C</a></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>I2C driver is built on top of the SCB hardware block. The SCB3 instance is used as an example for all code snippets. Modify the code to match your design.</dd></dl>
<h2><a class="anchor" id="group_scb_i2c_config"></a>
Configure I2C</h2>
<p>To set up the I2C driver, provide the configuration parameters in the <a class="el" href="structcy__stc__scb__i2c__config__t.html">cy_stc_scb_i2c_config_t</a> structure. Provide i2cMode to the select operation mode slave, master or master-slave. The useRxFifo and useTxFifo parameters specify if RX and TX FIFO is used during operation. Typically, both FIFOs should be enabled to reduce possibility of clock stretching. However, using RX FIFO has side effects that needs to be taken into account (see useRxFifo field description in <a class="el" href="structcy__stc__scb__i2c__config__t.html">cy_stc_scb_i2c_config_t</a> structure). For master modes, parameters lowPhaseDutyCycle, highPhaseDutyCycle and enableDigitalFilter can be used to define output data rate (refer to section <a class="el" href="group__group__scb__i2c.html#group_scb_i2c_data_rate">Configure Data Rate</a> for more information). For slave mode, provide the slaveAddress and slaveAddressMask. The other parameters are optional for operation.<br />
To initialize the driver, call Cy_SCB_I2C_Init function providing a pointer to the populated <a class="el" href="structcy__stc__scb__i2c__config__t.html">cy_stc_scb_i2c_config_t</a> structure and the allocated <a class="el" href="structcy__stc__scb__i2c__context__t.html">cy_stc_scb_i2c_context_t</a> structure.</p>
<div class="fragment"></div><!-- fragment --><p> Set up I2C slave read and write buffer before enabling its operation using Cy_SCB_I2C_SlaveConfigReadBuf and Cy_SCB_I2C_SlaveConfigWriteBuf appropriately. Note that the master reads data from the slave read buffer and writes data into the slave write buffer.</p>
<div class="fragment"></div><!-- fragment --><h2><a class="anchor" id="group_scb_i2c_pins"></a>
Assign and Configure Pins</h2>
<p>Only dedicated SCB pins can be used for I2C operation. The HSIOM register must be configured to connect dedicated SCB I2C pins to the SCB block. Also the I2C pins must be configured in Open-Drain, Drives Low mode (this pins configuration implies usage of external pull-up resistors):</p>
<div class="fragment"></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>The alternative pins configuration is Resistive Pull-ups which implies usage internal pull-up resistors. This configuration is not recommended because resistor value is fixed and cannot be used for all supported data rates. Refer to the device datasheet parameter RPULLUP for resistor value specifications.</dd></dl>
<h2><a class="anchor" id="group_scb_i2c_clock"></a>
Assign Clock Divider</h2>
<p>A clock source must be connected to the SCB block to oversample input and output signals, in this document this clock will be referred as clk_scb. You must use one of the 8-bit or 16-bit dividers. Use the <a class="el" href="group__group__sysclk.html">SysClk (System Clock)</a> driver API to do this.</p>
<div class="fragment"></div><!-- fragment --><h2><a class="anchor" id="group_scb_i2c_data_rate"></a>
Configure Data Rate</h2>
<p>To get I2C slave operation with the desired data rate, the clk_scb must be fast enough to provide sufficient oversampling. Use the <a class="el" href="group__group__sysclk.html">SysClk (System Clock)</a> driver API to do this.</p>
<div class="fragment"></div><!-- fragment --><p> To get I2C master operation with the desired data rate, the source clock frequency and SCL low and high phase duration must be configured. Use the <a class="el" href="group__group__sysclk.html">SysClk (System Clock)</a> driver API to configure source clock frequency. Then call Cy_SCB_I2C_SetDataRate to set the SCL low, high phase duration and digital filter. This function sets SCL low and high phase settings based on source clock frequency.</p>
<div class="fragment"></div><!-- fragment --><p> Alternatively, the low, high phase and digital filter can be set directly using configuration structure <a class="el" href="structcy__stc__scb__i2c__config__t.html">cy_stc_scb_i2c_config_t</a> fields lowPhaseDutyCycle, highPhaseDutyCycle and enableDigitalFilter appropriately.<br />
<b>Refer to the technical reference manual (TRM) section I2C sub-section Oversampling and Bit Rate to get information how to configure I2C to run with the desired data rate.</b></p>
<dl class="section note"><dt>Note</dt><dd>For I2C slave, the analog filter is used for all supported data rates. <br />
For I2C master, the analog filter is used for Standard and Fast modes and the digital filter for Fast Plus mode.</dd></dl>
<h2><a class="anchor" id="group_scb_i2c_intr"></a>
Configure Interrupt</h2>
<p>The interrupt is mandatory for I2C operation. The exception is the when only the <a class="el" href="group__group__scb__i2c__master__low__level__functions.html">Master Low-Level</a> functions are used. The driver provides three interrupt functions: Cy_SCB_I2C_Interrupt, Cy_SCB_I2C_SlaveInterrupt, and Cy_SCB_I2C_MasterInterrupt. One of these functions must be called in the interrupt handler for the selected SCB instance. Call Cy_SCB_I2C_SlaveInterrupt when I2C is configured to operate as a slave, Cy_SCB_I2C_MasterInterrupt when I2C is configured to operate as a master and Cy_SCB_I2C_Interrupt when I2C is configured to operate as master and slave. Using the slave- or master-specific interrupt function allows reducing the flash consumed by the I2C driver. Also this interrupt must be enabled in the NVIC otherwise it will not work. </p><dl class="section note"><dt>Note</dt><dd>The I2C driver documentation refers to the Cy_SCB_I2C_Interrupt function when interrupt processing is mandatory for the operation. This is done to simplify the readability of the driver's documentation. The application should call the slave- or master-specific interrupt functions Cy_SCB_I2C_SlaveInterrupt or Cy_SCB_I2C_MasterInterrupt, when appropriate.</dd></dl>
<div class="fragment"></div><!-- fragment --><div class="fragment"></div><!-- fragment --><h2><a class="anchor" id="group_scb_i2c_enable"></a>
Enable I2C</h2>
<p>Finally, enable the I2C operation by calling <a class="el" href="group__group__scb__i2c__general__functions.html#gad14d83faab69d2ac96feede664df3687">Cy_SCB_I2C_Enable</a>. Then I2C slave starts respond to the assigned address and I2C master ready to execute transfers.</p>
<div class="fragment"></div><!-- fragment --> <h1><a class="anchor" id="group_scb_i2c_use_cases"></a>
Common Use Cases</h1>
<h2><a class="anchor" id="group_scb_i2c_master_mode"></a>
Master Operation</h2>
<p>The master API is divided into two categories: <a class="el" href="group__group__scb__i2c__master__high__level__functions.html">Master High-Level</a> and <a class="el" href="group__group__scb__i2c__master__low__level__functions.html">Master Low-Level</a>. Therefore, there are two methods for initiating I2C master transactions using either <b>Low-Level or High-Level</b> API. These two methods are described below. Only one method should be used at a time. <b>They should not be mixed.</b></p>
<h3><a class="anchor" id="group_scb_i2c_master_hl"></a>
Use High-Level Functions</h3>
<p>Call Cy_SCB_I2C_MasterRead or Cy_SCB_I2C_MasterWrite to communicate with the slave. These functions do not block and only start a transaction. After a transaction starts, the Cy_SCB_I2C_Interrupt handles further data transaction until its completion (successfully or with error occurring). To monitor the transaction, use Cy_SCB_I2C_MasterGetStatus or register callback function using <a class="el" href="group__group__scb__i2c__interrupt__functions.html#gac61f7304c304421a40135cf4d61a660c">Cy_SCB_I2C_RegisterEventCallback</a> to be notified about <a class="el" href="group__group__scb__i2c__macros__callback__events.html">I2C Callback Events</a>.</p>
<div class="fragment"></div><!-- fragment --><h3><a class="anchor" id="group_scb_i2c_master_ll"></a>
Use Low-Level Functions</h3>
<p>Call Cy_SCB_I2C_MasterSendStart to generate a start, send an address with the Read/Write direction bit, and receive acknowledgment. After the address is ACKed by the slave, the transaction can be continued by calling Cy_SCB_I2C_MasterReadByte or Cy_SCB_I2C_MasterWriteByte depending on its direction. These functions handle one byte per call. Therefore, they should be called for each byte in the transaction. Note that for the Read transaction, the last byte must be NAKed. To complete the current transaction, call Cy_SCB_I2C_MasterSendStop or call Cy_SCB_I2C_MasterSendReStart to complete the current transaction and start a new one. Typically, do a restart to change the transaction direction without releasing the bus from the master control. The Low-Level functions are blocking and do not require calling Cy_SCB_I2C_Interrupt inside the interrupt handler. Using these functions requires extensive knowledge of the I2C protocol to execute transactions correctly.</p>
<p><b>Master Write Operation</b> </p><div class="fragment"></div><!-- fragment --><p> <b>Master Read Operation</b> </p><div class="fragment"></div><!-- fragment --><h2><a class="anchor" id="group_scb_i2c_slave"></a>
Slave Operation</h2>
<p>Slave operation requires the Cy_SCB_I2C_Interrupt be called inside the interrupt handler. The read and write buffers must be provided for the slave to enable communication with the master. Use Cy_SCB_I2C_SlaveConfigReadBuf and Cy_SCB_I2C_SlaveConfigWriteBuf for this purpose. Note that after transaction completion the buffer must be configured again. Otherwise, the same buffer is used starting from the point where the master stopped a previous transaction. For example: The read buffer is configured to be 10 bytes and the master reads 8 bytes. If the read buffer is not configured again, the next master read will start from the 9th byte. To monitor the transaction status, use Cy_SCB_I2C_SlaveGetStatus or use <a class="el" href="group__group__scb__i2c__interrupt__functions.html#gac61f7304c304421a40135cf4d61a660c">Cy_SCB_I2C_RegisterEventCallback</a> to register a callback function to be notified about <a class="el" href="group__group__scb__i2c__macros__callback__events.html">I2C Callback Events</a>.</p>
<p><b>Get Slave Events Notification</b> </p><div class="fragment"></div><!-- fragment --><div class="fragment"></div><!-- fragment --><p> <b>Polling Slave Completion Events</b> </p><div class="fragment"></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>All slave API (except Cy_SCB_I2C_SlaveAbortRead and Cy_SCB_I2C_SlaveAbortWrite) <b>are not interrupt-protected</b> and to prevent a race condition, they should be protected from the I2C interruption in the place where they are called. The code snippet Polling Slave Completion Events above shows how to prevent a race condition when detect transfer completion and update I2C slave write buffer. The simple example of race condition is: application updates slave read buffer the I2C master starts read transfer. The I2C interrupts read buffer update and I2C interrupt loads current read buffer content in the TX FIFO . After I2C interrupt returns the application updates remaining part of the read buffer. As a result the mater read partly updated buffer.</dd></dl>
<h1><a class="anchor" id="group_scb_i2c_lp"></a>
Low Power Support</h1>
<p>The I2C driver provides callback functions to handle power mode transition. The callback Cy_SCB_I2C_DeepSleepCallback must be called during execution of Cy_SysPm_CpuEnterDeepSleep Cy_SCB_I2C_HibernateCallback must be called during execution of Cy_SysPm_SystemEnterHibernate. To trigger the callback execution, the callback must be registered before calling the power mode transition function. Refer to <a class="el" href="group__group__syspm.html">SysPm (System Power Management)</a> driver for more information about power mode transitions and callback registration.</p>
<dl class="section note"><dt>Note</dt><dd>Only applicable for <b>rev-08 of the CY8CKIT-062-BLE</b>. For proper operation, when the I2C slave is configured to be a wakeup source from Deep Sleep mode, the Cy_SCB_I2C_DeepSleepCallback must be copied and modified. Refer to the function description to get the details. </dd></dl>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
API Reference</h2></td></tr>
<tr class="memitem:group__group__scb__i2c__macros"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__i2c__macros.html">Macros</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__scb__i2c__functions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__i2c__functions.html">Functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__scb__i2c__data__structures"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__i2c__data__structures.html">Data Structures</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__scb__i2c__enums"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__i2c__enums.html">Enumerated Types</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__scb__i2c__general__functions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__i2c__general__functions.html">General</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__scb__i2c__slave__functions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__i2c__slave__functions.html">Slave</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__scb__i2c__master__high__level__functions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__i2c__master__high__level__functions.html">Master High-Level</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__scb__i2c__master__low__level__functions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__i2c__master__low__level__functions.html">Master Low-Level</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__scb__i2c__interrupt__functions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__i2c__interrupt__functions.html">Interrupt</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__scb__i2c__low__power__functions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__i2c__low__power__functions.html">Low Power Callbacks</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>MTB CAT5 Peripheral driver library</b> by <b>Infineon Technologies</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
