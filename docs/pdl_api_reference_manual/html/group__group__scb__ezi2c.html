<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MTB CAT5 Peripheral driver library: EZI2C (SCB)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.infineon.com/"><img alt="Logo" src="IFX_LOGO_RGB.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MTB CAT5 Peripheral driver library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li><a href="page_getting_started.html"><span>Getting&#160;started</span></a></li>
      <li><a href="modules.html"><span>PDL&#160;API&#160;Reference</span></a></li>
      <li><a href="usergroup0.html"><span>Online&#160;Documentation</span></a></li>
      <li><a href="usergroup1.html"><span>Device&#160;Catalog</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)"
               onblur="searchBox.OnSearchFieldFocus(false)"
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__scb__ezi2c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0"
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">API Reference</a>  </div>
  <div class="headertitle">
<div class="title">EZI2C (SCB)<div class="ingroups"><a class="el" href="group__group__scb.html">SCB          (Serial Communication Block)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p>Driver API for EZI2C Slave Peripheral. </p>
<p>The functions and other declarations used in this part of the driver are in cy_scb_ezi2c.h. You can also include cy_pdl.h to get access to all functions and declarations in the PDL.</p>
<p>I2C - The Inter-Integrated Circuit (I2C) bus is an industry-standard.</p>
<p>The EZI2C slave peripheral driver provides an API to implement the I2C slave device based on the SCB hardware block. This slave device emulates a common I2C EEPROM interface that acts like dual-port memory between the external master and your code. I2C devices based on the SCB hardware are compatible with the I2C Standard mode, Fast mode, and Fast mode Plus specifications, as defined in the I2C bus specification.</p>
<p>EZI2C slave is a special implementation of the I2C that handles all communication between the master and slave through ISR (interrupt service routine) and requires no interaction with the main program flow from the slave side. The EZI2C should be used when a shared memory model between the I2C master and I2C slave is needed.</p>
<p>Features:</p><ul>
<li>An industry-standard I2C bus interface</li>
<li>Supports standard data rates of 100/400/1000 kbps</li>
<li>Emulates a common I2C EEPROM Interface</li>
<li>Acts like dual-port memory between the external master and your code</li>
<li>Supports Hardware Address Match</li>
<li>Supports two hardware addresses with separate buffers</li>
<li>On deep sleep-capable SCB, it supports wake from deep sleep on address match</li>
<li>Simple to set up and use; does not require calling EZI2C API at run time.</li>
</ul>
<h1><a class="anchor" id="group_scb_ezi2c_configuration"></a>
Configuration Considerations</h1>
<p>The EZI2C slave driver configuration can be divided to number of sequential steps listed below:</p><ul>
<li><a class="el" href="group__group__scb__ezi2c.html#group_scb_ezi2c_config">Configure EZI2C slave</a></li>
<li><a class="el" href="group__group__scb__ezi2c.html#group_scb_ezi2c_pins">Assign and Configure Pins</a></li>
<li><a class="el" href="group__group__scb__ezi2c.html#group_scb_ezi2c_clock">Assign Clock Divider</a></li>
<li><a class="el" href="group__group__scb__ezi2c.html#group_scb_ezi2c_data_rate">Configure Data Rate</a></li>
<li><a class="el" href="group__group__scb__ezi2c.html#group_scb_ezi2c_intr">Configure Interrupt</a></li>
<li><a class="el" href="group__group__scb__ezi2c.html#group_scb_ezi2c_enable">Enable EZI2C slave</a></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>EZI2C slave driver is built on top of the SCB hardware block. The SCB3 instance is used as an example for all code snippets. Modify the code to match your design.</dd></dl>
<h2><a class="anchor" id="group_scb_ezi2c_config"></a>
Configure EZI2C slave</h2>
<p>To set up the EZI2C slave driver, provide the configuration parameters in the <a class="el" href="structcy__stc__scb__ezi2c__config__t.html">cy_stc_scb_ezi2c_config_t</a> structure. The primary slave address slaveAddress1 must be provided. The other parameters are optional for operation. To initialize the driver, call Cy_SCB_EZI2C_Init function providing a pointer to the populated <a class="el" href="structcy__stc__scb__ezi2c__config__t.html">cy_stc_scb_ezi2c_config_t</a> structure and the allocated <a class="el" href="structcy__stc__scb__ezi2c__context__t.html">cy_stc_scb_ezi2c_context_t</a> structure.</p>
<div class="fragment"></div><!-- fragment --><p> Set up the EZI2C slave buffer before enabling its operation by using Cy_SCB_EZI2C_SetBuffer1 for the primary slave address and Cy_SCB_EZI2C_SetBuffer2 for the secondary (if the secondary is enabled).</p>
<div class="fragment"></div><!-- fragment --><h2><a class="anchor" id="group_scb_ezi2c_pins"></a>
Assign and Configure Pins</h2>
<p>Only dedicated SCB pins can be used for I2C operation. The HSIOM register must be configured to connect dedicated SCB I2C pins to the SCB block. Also the I2C pins must be configured in Open-Drain, Drives Low mode (this pin configuration implies usage of external pull-up resistors):</p>
<div class="fragment"></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>The alternative pins configuration is Resistive Pull-ups which implies usage internal pull-up resistors. This configuration is not recommended because resistor value is fixed and cannot be used for all supported data rates. Refer to device datasheet parameter RPULLUP for resistor value specifications.</dd></dl>
<h2><a class="anchor" id="group_scb_ezi2c_clock"></a>
Assign Clock Divider</h2>
<p>A clock source must be connected to the SCB block to oversample input and output signals, in this document this clock will be referred as clk_scb. You must use one of the 8-bit or 16-bit dividers. Use the <a class="el" href="group__group__sysclk.html">SysClk (System Clock)</a> driver API to do this.</p>
<div class="fragment"></div><!-- fragment --><h2><a class="anchor" id="group_scb_ezi2c_data_rate"></a>
Configure Data Rate</h2>
<p>To get EZI2C slave to operate at the desired data rate, the clk_scb must be fast enough to provide sufficient oversampling. Use the <a class="el" href="group__group__sysclk.html">SysClk (System Clock)</a> driver API to do this.</p>
<p><b>Refer to the technical reference manual (TRM) section I2C sub-section Oversampling and Bit Rate to get information about how to configure the I2C to run at the desired data rate</b>.</p>
<div class="fragment"></div><!-- fragment --><h2><a class="anchor" id="group_scb_ezi2c_intr"></a>
Configure Interrupt</h2>
<p>The interrupt is mandatory for the EZI2C slave operation. The Cy_SCB_EZI2C_Interrupt function must be called in the interrupt handler for the selected SCB instance. Also, this interrupt must be enabled in the NVIC or it will not work.</p>
<div class="fragment"></div><!-- fragment --><div class="fragment"></div><!-- fragment --><h2><a class="anchor" id="group_scb_ezi2c_enable"></a>
Enable EZI2C slave</h2>
<p>Finally, enable the EZI2C slave operation by calling <a class="el" href="group__group__scb__ezi2c__general__functions.html#gae5c13ff7a89e0a75fbe83bd5dfc4fc95">Cy_SCB_EZI2C_Enable</a>. Now the I2C device responds to the assigned address. </p><div class="fragment"></div><!-- fragment --><h1><a class="anchor" id="group_scb_ezi2c_use_cases"></a>
Common Use Cases</h1>
<p>The EZI2C slave operation might not require calling any EZI2C slave function because the I2C master is able to access the slave buffer. The application can directly access it as well. Note that this is an application-level task to ensure the buffer content integrity.</p>
<h2><a class="anchor" id="group_scb_ezi2c_master_wr"></a>
Master Write operation</h2>
<p>This operation starts with sending a base address that is one or two bytes, depending on the sub-address size configuration. This base address is retained and will be used for later read operations. Following the base address, there is a sequence of bytes written into the buffer starting from the base address location. The buffer index is incremented for each written byte, but this does not affect the base address that is retained. The length of a write operation is limited by the maximum buffer read/write region size.<br />
When a master attempts to write outside the read/write region or past the end of the buffer, the last byte is NACKed.</p>
<div class="image">
<img src="scb_ezi2c_write.png" alt="scb_ezi2c_write.png"/>
</div>
<h2><a class="anchor" id="group_scb_ezi2c_master_rd"></a>
Master Read operation</h2>
<p>This operation always starts from the base address set by the most recent write operation. The buffer index is incremented for each read byte. Two sequential read operations start from the same base address no matter how many bytes are read. The length of a read operation is not limited by the maximum size of the data buffer. The EZI2C slave returns 0xFF bytes if the read operation passes the end of the buffer.<br />
Typically, a read operation requires the base address to be updated before starting the read. In this case, the write and read operations must be combined together.</p>
<div class="image">
<img src="scb_ezi2c_read.png" alt="scb_ezi2c_read.png"/>
</div>
<p>The I2C master may use the ReStart or Stop/Start conditions to combine the operations. The write operation sets only the base address and the following read operation will start from the new base address. In cases where the base address remains the same, there is no need for a write operation. </p><div class="image">
<img src="scb_ezi2c_set_ba_read.png" alt="scb_ezi2c_set_ba_read.png"/>
</div>
<h1><a class="anchor" id="group_scb_ezi2c_lp"></a>
Low Power Support</h1>
<p>The EZI2C slave provides the callback functions to handle power mode transition. The callback Cy_SCB_EZI2C_DeepSleepCallback must be called during execution of Cy_SysPm_CpuEnterDeepSleep; Cy_SCB_EZI2C_HibernateCallback must be called during execution of Cy_SysPm_SystemEnterHibernate. To trigger the callback execution, the callback must be registered before calling the power mode transition function. Refer to <a class="el" href="group__group__syspm.html">SysPm (System Power Management)</a> driver for more information about power mode transitions and callback registration.</p>
<p>The EZI2C configured to support two addresses can wakeup the device on address match to NACK not supported address. This happens because the hardware address-match-logic uses address bit masking to support to two addresses. The address mask defines which bits in the address are treated as non-significant while performing an address match. One non-significant bit results in two matching addresses; two bits will match 4 and so on. If the two addresses differ by more than a single bit, then the extra addresses that will pass the hardware match and wakeup the device from Deep Sleep mode. Then firmware address matching will to generate a NAK. Due to this reason, it is preferable to select a secondary address that is different from the primary by one bit. The address mask in this case makes one bit non-significant. For example:</p><ul>
<li>Primary address = 0x24 and secondary address = 0x34, only one bit differs. Only the two addresses are treated as matching by the hardware.</li>
<li>Primary address = 0x24 and secondary address = 0x30, two bits differ. Four addresses are treated as matching by the hardware: 0x24, 0x34, 0x20 and 0x30. Firmware is required to ACK only the primary and secondary addresses 0x24 and 0x30 and NAK all others 0x20 and 0x34.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Only applicable for <b>rev-08 of the CY8CKIT-062-BLE</b>. For proper operation, when the EZI2C slave is configured to be a wakeup source from Deep Sleep mode, the Cy_SCB_EZI2C_DeepSleepCallback must be copied and modified. Refer to the function description to get the details. </dd></dl>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
API Reference</h2></td></tr>
<tr class="memitem:group__group__scb__ezi2c__macros"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__ezi2c__macros.html">Macros</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__scb__ezi2c__functions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__ezi2c__functions.html">Functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__scb__ezi2c__data__structures"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__ezi2c__data__structures.html">Data Structures</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__scb__ezi2c__enums"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__ezi2c__enums.html">Enumerated Types</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__scb__ezi2c__general__functions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__ezi2c__general__functions.html">General</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__scb__ezi2c__slave__functions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__ezi2c__slave__functions.html">Slave</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__scb__ezi2c__low__power__functions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__scb__ezi2c__low__power__functions.html">Low Power Callbacks</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>MTB CAT5 Peripheral driver library</b> by <b>Infineon Technologies</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
